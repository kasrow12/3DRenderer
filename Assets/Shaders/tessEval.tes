#version 400 core

layout (quads, equal_spacing, cw) in;

in vec3 tcFragPos[];
out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

// Bezier blending function (Bernstein polynomial)
float bernstein(int i, float u) {
    switch (i) {
        case 0: return (1-u)*(1-u)*(1-u);
        case 1: return 3*u*(1-u)*(1-u);
        case 2: return 3*u*u*(1-u);
        case 3: return u*u*u;
    }
    return 0.0; // Should never happen
}

// Function to calculate the Bezier surface point
vec3 calculateBezierPoint(vec2 uv) {
    vec3 point = vec3(0.0);
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            float b_i = bernstein(i, uv.x);
            float b_j = bernstein(j, uv.y);
            point += tcFragPos[i * 4 + j] * b_i * b_j;
        }
    }
    return point;
}

void main()
{
    vec2 uv = vec2(gl_TessCoord.x, gl_TessCoord.y);

    // Calculate Bezier surface point
    FragPos = calculateBezierPoint(uv);

    // Calculate normal using finite differences
    float offset = 0.001; // Small offset for finite differences

    // Calculate tangent vectors using finite differences
    vec2 uv_x = uv + vec2(offset, 0.0);
    vec2 uv_y = uv + vec2(0.0, offset);

    // Clamp the values to stay within 0-1 range
    uv_x = clamp(uv_x, 0.0, 1.0);
    uv_y = clamp(uv_y, 0.0, 1.0);

    vec3 point_x = calculateBezierPoint(uv_x);
    vec3 point_y = calculateBezierPoint(uv_y);

    vec3 tangent_u = point_x - FragPos;
    vec3 tangent_v = point_y - FragPos;

    Normal = mat3(transpose(inverse(model))) * normalize(cross(tangent_u, tangent_v));

    TexCoords = uv;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}